/**
 * AI Context Manager
 *
 * Manages context for AI writing assistants to ensure consistency across
 * 12,000+ chapter narratives. Automatically curates relevant information
 * for each writing session based on what's being written.
 */

import { v4 as uuidv4 } from 'uuid';

// ============================================================================
// ENUMS
// ============================================================================

export enum ContextType {
  // Story Elements
  CHARACTER = 'character',
  LOCATION = 'location',
  ITEM = 'item',
  ORGANIZATION = 'organization',
  EVENT = 'event',
  RELATIONSHIP = 'relationship',

  // World Elements
  WORLD_RULE = 'world_rule',
  MAGIC_RULE = 'magic_rule',
  CULTURAL_RULE = 'cultural_rule',
  TIMELINE = 'timeline',

  // Writing Elements
  STYLE_GUIDE = 'style_guide',
  CHARACTER_VOICE = 'character_voice',
  SCENE_TEMPLATE = 'scene_template',
  PLOT_THREAD = 'plot_thread',

  // Meta
  PREVIOUS_CHAPTER = 'previous_chapter',
  CHAPTER_OUTLINE = 'chapter_outline',
  ARC_SUMMARY = 'arc_summary',
  CUSTOM = 'custom'
}

export enum ContextPriority {
  CRITICAL = 'critical',       // Must always include
  HIGH = 'high',               // Include if space allows
  MEDIUM = 'medium',           // Include if relevant
  LOW = 'low',                 // Include only if specifically needed
  REFERENCE = 'reference'      // Available but not auto-included
}

export enum ContextScope {
  GLOBAL = 'global',           // Applies to entire story
  ARC = 'arc',                 // Applies to story arc
  VOLUME = 'volume',           // Applies to volume
  CHAPTER = 'chapter',         // Applies to specific chapter
  SCENE = 'scene'              // Applies to specific scene
}

// ============================================================================
// INTERFACES
// ============================================================================

export interface ContextPiece {
  id: string;
  name: string;
  type: ContextType;
  priority: ContextPriority;
  scope: ContextScope;
  content: string;
  summary: string;              // Short version for token-limited contexts
  tokenEstimate: number;
  relatedEntities: string[];    // Entity IDs this context relates to
  relatedChapters: number[];
  tags: string[];
  validFrom?: number;           // Chapter number where this becomes valid
  validUntil?: number;          // Chapter number where this stops being valid
  lastUpdated: Date;
  version: number;
}

export interface ContextBundle {
  id: string;
  name: string;
  description: string;
  pieces: string[];             // Context piece IDs
  totalTokens: number;
  autoGenerated: boolean;
  forChapter?: number;
  forScene?: string;
  createdAt: Date;
}

export interface ContextRequest {
  chapterNumber: number;
  sceneIndex?: number;
  povCharacterId?: string;
  locationId?: string;
  involvedCharacterIds?: string[];
  plotThreadIds?: string[];
  maxTokens?: number;
  requiredTypes?: ContextType[];
  excludeTypes?: ContextType[];
  includeIds?: string[];        // Specific context IDs to include
  excludeIds?: string[];        // Specific context IDs to exclude
}

export interface GeneratedContext {
  bundleId: string;
  systemPrompt: string;
  characterContext: string;
  worldContext: string;
  plotContext: string;
  styleContext: string;
  recentContext: string;
  fullContext: string;
  tokenCount: number;
  includedPieces: ContextPiece[];
  excludedPieces: { piece: ContextPiece; reason: string }[];
  warnings: string[];
}

export interface ContextTemplate {
  id: string;
  name: string;
  description: string;
  systemPromptTemplate: string;
  requiredContextTypes: ContextType[];
  optionalContextTypes: ContextType[];
  maxTokens: number;
  placeholders: string[];       // {{character_name}}, {{location}}, etc.
}

export interface WritingSession {
  id: string;
  chapterNumber: number;
  sceneIndex?: number;
  startedAt: Date;
  contextBundleId: string;
  promptsSent: PromptRecord[];
  responsesReceived: ResponseRecord[];
  notes: string;
  status: 'active' | 'paused' | 'completed' | 'abandoned';
}

export interface PromptRecord {
  id: string;
  timestamp: Date;
  prompt: string;
  contextIncluded: string[];
  tokenCount: number;
  purpose: string;
}

export interface ResponseRecord {
  id: string;
  promptId: string;
  timestamp: Date;
  response: string;
  tokenCount: number;
  accepted: boolean;
  edits?: string;
  notes?: string;
}

// ============================================================================
// CONTEXT MANAGER
// ============================================================================

export class ContextManager {
  private contexts: Map<string, ContextPiece> = new Map();
  private bundles: Map<string, ContextBundle> = new Map();
  private templates: Map<string, ContextTemplate> = new Map();
  private sessions: Map<string, WritingSession> = new Map();

  // Indexes for fast lookup
  private contextsByType: Map<ContextType, Set<string>> = new Map();
  private contextsByEntity: Map<string, Set<string>> = new Map();
  private contextsByChapter: Map<number, Set<string>> = new Map();
  private contextsByTag: Map<string, Set<string>> = new Map();

  constructor() {
    this.initializeDefaultTemplates();
  }

  // ==========================================================================
  // DEFAULT TEMPLATES
  // ==========================================================================

  private initializeDefaultTemplates(): void {
    // Standard chapter writing template
    this.addTemplate({
      id: 'standard-chapter',
      name: 'Standard Chapter Writing',
      description: 'Template for writing a typical chapter',
      systemPromptTemplate: `You are a skilled fiction writer helping to write Chapter {{chapter_number}} of an epic narrative.

CRITICAL RULES:
{{world_rules}}

CURRENT SCENE:
- Location: {{location}}
- POV Character: {{pov_character}}
- Time: {{timeline_position}}

CHARACTERS PRESENT:
{{character_summaries}}

PLOT THREADS TO ADVANCE:
{{active_plot_threads}}

STYLE GUIDELINES:
{{style_guide}}

Write in a way that maintains consistency with established facts and character voices.`,
      requiredContextTypes: [
        ContextType.WORLD_RULE,
        ContextType.CHARACTER,
        ContextType.STYLE_GUIDE
      ],
      optionalContextTypes: [
        ContextType.LOCATION,
        ContextType.PLOT_THREAD,
        ContextType.PREVIOUS_CHAPTER,
        ContextType.RELATIONSHIP
      ],
      maxTokens: 8000,
      placeholders: [
        '{{chapter_number}}',
        '{{location}}',
        '{{pov_character}}',
        '{{timeline_position}}',
        '{{world_rules}}',
        '{{character_summaries}}',
        '{{active_plot_threads}}',
        '{{style_guide}}'
      ]
    });

    // Dialogue-heavy scene template
    this.addTemplate({
      id: 'dialogue-scene',
      name: 'Dialogue Scene',
      description: 'Template for dialogue-heavy scenes',
      systemPromptTemplate: `You are writing a dialogue-heavy scene in Chapter {{chapter_number}}.

CHARACTER VOICES (CRITICAL - maintain these speech patterns):
{{character_voices}}

RELATIONSHIPS BETWEEN CHARACTERS:
{{relationships}}

WHAT EACH CHARACTER KNOWS:
{{character_knowledge}}

SCENE CONTEXT:
{{scene_context}}

STYLE NOTES:
- Use dialogue tags sparingly
- Show character through speech patterns
- Maintain each character's unique voice`,
      requiredContextTypes: [
        ContextType.CHARACTER_VOICE,
        ContextType.RELATIONSHIP
      ],
      optionalContextTypes: [
        ContextType.LOCATION,
        ContextType.PLOT_THREAD
      ],
      maxTokens: 6000,
      placeholders: [
        '{{chapter_number}}',
        '{{character_voices}}',
        '{{relationships}}',
        '{{character_knowledge}}',
        '{{scene_context}}'
      ]
    });

    // Action scene template
    this.addTemplate({
      id: 'action-scene',
      name: 'Action Scene',
      description: 'Template for action/combat scenes',
      systemPromptTemplate: `You are writing an action scene in Chapter {{chapter_number}}.

MAGIC/POWER RULES (CRITICAL - do not violate):
{{magic_rules}}

CHARACTER ABILITIES:
{{character_abilities}}

LOCATION LAYOUT:
{{location_details}}

STAKES AND CONSEQUENCES:
{{stakes}}

PACING NOTES:
- Short, punchy sentences for high action
- Clear spatial awareness
- Consequences for actions`,
      requiredContextTypes: [
        ContextType.MAGIC_RULE,
        ContextType.CHARACTER,
        ContextType.LOCATION
      ],
      optionalContextTypes: [
        ContextType.WORLD_RULE,
        ContextType.ITEM
      ],
      maxTokens: 5000,
      placeholders: [
        '{{chapter_number}}',
        '{{magic_rules}}',
        '{{character_abilities}}',
        '{{location_details}}',
        '{{stakes}}'
      ]
    });

    // Emotional/introspective scene template
    this.addTemplate({
      id: 'introspective-scene',
      name: 'Introspective Scene',
      description: 'Template for emotional or introspective scenes',
      systemPromptTemplate: `You are writing an introspective scene in Chapter {{chapter_number}}.

POV CHARACTER DEEP PROFILE:
{{character_profile}}

CHARACTER'S EMOTIONAL STATE:
{{emotional_context}}

WHAT THEY'RE PROCESSING:
{{recent_events}}

CHARACTER ARC POSITION:
{{arc_position}}

INTERNAL VOICE STYLE:
{{internal_voice}}

Write with deep emotional authenticity while maintaining the character's established voice.`,
      requiredContextTypes: [
        ContextType.CHARACTER,
        ContextType.CHARACTER_VOICE
      ],
      optionalContextTypes: [
        ContextType.PREVIOUS_CHAPTER,
        ContextType.RELATIONSHIP
      ],
      maxTokens: 4000,
      placeholders: [
        '{{chapter_number}}',
        '{{character_profile}}',
        '{{emotional_context}}',
        '{{recent_events}}',
        '{{arc_position}}',
        '{{internal_voice}}'
      ]
    });
  }

  // ==========================================================================
  // CONTEXT PIECE MANAGEMENT
  // ==========================================================================

  addContext(data: Omit<ContextPiece, 'id' | 'lastUpdated' | 'version' | 'tokenEstimate'>): ContextPiece {
    const piece: ContextPiece = {
      id: uuidv4(),
      ...data,
      tokenEstimate: this.estimateTokens(data.content),
      lastUpdated: new Date(),
      version: 1
    };

    this.contexts.set(piece.id, piece);
    this.indexContext(piece);

    return piece;
  }

  private indexContext(piece: ContextPiece): void {
    // Index by type
    if (!this.contextsByType.has(piece.type)) {
      this.contextsByType.set(piece.type, new Set());
    }
    this.contextsByType.get(piece.type)!.add(piece.id);

    // Index by related entities
    for (const entityId of piece.relatedEntities) {
      if (!this.contextsByEntity.has(entityId)) {
        this.contextsByEntity.set(entityId, new Set());
      }
      this.contextsByEntity.get(entityId)!.add(piece.id);
    }

    // Index by chapters
    for (const chapter of piece.relatedChapters) {
      if (!this.contextsByChapter.has(chapter)) {
        this.contextsByChapter.set(chapter, new Set());
      }
      this.contextsByChapter.get(chapter)!.add(piece.id);
    }

    // Index by tags
    for (const tag of piece.tags) {
      if (!this.contextsByTag.has(tag)) {
        this.contextsByTag.set(tag, new Set());
      }
      this.contextsByTag.get(tag)!.add(piece.id);
    }
  }

  updateContext(id: string, updates: Partial<ContextPiece>): boolean {
    const piece = this.contexts.get(id);
    if (!piece) return false;

    // Remove from indexes
    this.removeFromIndexes(piece);

    // Apply updates
    Object.assign(piece, updates);
    piece.lastUpdated = new Date();
    piece.version++;

    if (updates.content) {
      piece.tokenEstimate = this.estimateTokens(updates.content);
    }

    // Re-index
    this.indexContext(piece);

    return true;
  }

  private removeFromIndexes(piece: ContextPiece): void {
    this.contextsByType.get(piece.type)?.delete(piece.id);

    for (const entityId of piece.relatedEntities) {
      this.contextsByEntity.get(entityId)?.delete(piece.id);
    }

    for (const chapter of piece.relatedChapters) {
      this.contextsByChapter.get(chapter)?.delete(piece.id);
    }

    for (const tag of piece.tags) {
      this.contextsByTag.get(tag)?.delete(piece.id);
    }
  }

  getContext(id: string): ContextPiece | undefined {
    return this.contexts.get(id);
  }

  getAllContexts(): ContextPiece[] {
    return Array.from(this.contexts.values());
  }

  getContextsByType(type: ContextType): ContextPiece[] {
    const ids = this.contextsByType.get(type);
    if (!ids) return [];
    return Array.from(ids).map(id => this.contexts.get(id)!);
  }

  getContextsForEntity(entityId: string): ContextPiece[] {
    const ids = this.contextsByEntity.get(entityId);
    if (!ids) return [];
    return Array.from(ids).map(id => this.contexts.get(id)!);
  }

  getContextsForChapter(chapterNumber: number): ContextPiece[] {
    const ids = this.contextsByChapter.get(chapterNumber);
    if (!ids) return [];
    return Array.from(ids).map(id => this.contexts.get(id)!);
  }

  // ==========================================================================
  // TOKEN ESTIMATION
  // ==========================================================================

  private estimateTokens(text: string): number {
    // Rough estimation: ~4 characters per token for English
    // This is a simplified estimate; real tokenization varies by model
    return Math.ceil(text.length / 4);
  }

  // ==========================================================================
  // CONTEXT GENERATION
  // ==========================================================================

  generateContextForChapter(request: ContextRequest): GeneratedContext {
    const maxTokens = request.maxTokens || 8000;
    const includedPieces: ContextPiece[] = [];
    const excludedPieces: { piece: ContextPiece; reason: string }[] = [];
    const warnings: string[] = [];
    let currentTokens = 0;

    // Get all potentially relevant contexts
    const candidates = this.gatherCandidates(request);

    // Sort by priority and relevance
    const sortedCandidates = this.rankContexts(candidates, request);

    // Select contexts within token budget
    for (const piece of sortedCandidates) {
      // Check exclusions
      if (request.excludeIds?.includes(piece.id)) {
        excludedPieces.push({ piece, reason: 'Explicitly excluded' });
        continue;
      }

      if (request.excludeTypes?.includes(piece.type)) {
        excludedPieces.push({ piece, reason: 'Type excluded' });
        continue;
      }

      // Check validity for chapter
      if (piece.validFrom && piece.validFrom > request.chapterNumber) {
        excludedPieces.push({ piece, reason: 'Not yet valid for this chapter' });
        continue;
      }

      if (piece.validUntil && piece.validUntil < request.chapterNumber) {
        excludedPieces.push({ piece, reason: 'No longer valid for this chapter' });
        continue;
      }

      // Check token budget
      const pieceTokens = piece.priority === ContextPriority.CRITICAL
        ? piece.tokenEstimate
        : (currentTokens + piece.tokenEstimate > maxTokens * 0.8
          ? this.estimateTokens(piece.summary)
          : piece.tokenEstimate);

      if (currentTokens + pieceTokens > maxTokens) {
        if (piece.priority === ContextPriority.CRITICAL) {
          warnings.push(`Critical context "${piece.name}" may exceed token budget`);
          includedPieces.push(piece);
          currentTokens += pieceTokens;
        } else {
          excludedPieces.push({ piece, reason: 'Token budget exceeded' });
        }
        continue;
      }

      includedPieces.push(piece);
      currentTokens += pieceTokens;
    }

    // Build context sections
    const characterContext = this.buildSection(includedPieces, [
      ContextType.CHARACTER,
      ContextType.CHARACTER_VOICE,
      ContextType.RELATIONSHIP
    ]);

    const worldContext = this.buildSection(includedPieces, [
      ContextType.WORLD_RULE,
      ContextType.MAGIC_RULE,
      ContextType.CULTURAL_RULE,
      ContextType.LOCATION
    ]);

    const plotContext = this.buildSection(includedPieces, [
      ContextType.PLOT_THREAD,
      ContextType.EVENT,
      ContextType.CHAPTER_OUTLINE,
      ContextType.ARC_SUMMARY
    ]);

    const styleContext = this.buildSection(includedPieces, [
      ContextType.STYLE_GUIDE,
      ContextType.SCENE_TEMPLATE
    ]);

    const recentContext = this.buildSection(includedPieces, [
      ContextType.PREVIOUS_CHAPTER
    ]);

    // Build system prompt
    const systemPrompt = this.buildSystemPrompt(request, includedPieces);

    // Build full context
    const fullContext = [
      systemPrompt,
      '\n\n---\n\n',
      characterContext ? `## Characters\n${characterContext}\n\n` : '',
      worldContext ? `## World\n${worldContext}\n\n` : '',
      plotContext ? `## Plot\n${plotContext}\n\n` : '',
      styleContext ? `## Style\n${styleContext}\n\n` : '',
      recentContext ? `## Recent Events\n${recentContext}\n\n` : ''
    ].join('');

    // Create bundle
    const bundle: ContextBundle = {
      id: uuidv4(),
      name: `Chapter ${request.chapterNumber} Context`,
      description: `Auto-generated context for chapter ${request.chapterNumber}`,
      pieces: includedPieces.map(p => p.id),
      totalTokens: currentTokens,
      autoGenerated: true,
      forChapter: request.chapterNumber,
      forScene: request.sceneIndex?.toString(),
      createdAt: new Date()
    };

    this.bundles.set(bundle.id, bundle);

    return {
      bundleId: bundle.id,
      systemPrompt,
      characterContext,
      worldContext,
      plotContext,
      styleContext,
      recentContext,
      fullContext,
      tokenCount: currentTokens,
      includedPieces,
      excludedPieces,
      warnings
    };
  }

  private gatherCandidates(request: ContextRequest): ContextPiece[] {
    const candidateIds = new Set<string>();

    // Always include global scope with critical priority
    for (const piece of this.contexts.values()) {
      if (piece.scope === ContextScope.GLOBAL && piece.priority === ContextPriority.CRITICAL) {
        candidateIds.add(piece.id);
      }
    }

    // Include required types
    if (request.requiredTypes) {
      for (const type of request.requiredTypes) {
        const typeIds = this.contextsByType.get(type);
        if (typeIds) {
          for (const id of typeIds) {
            candidateIds.add(id);
          }
        }
      }
    }

    // Include contexts for involved characters
    if (request.involvedCharacterIds) {
      for (const charId of request.involvedCharacterIds) {
        const charContexts = this.contextsByEntity.get(charId);
        if (charContexts) {
          for (const id of charContexts) {
            candidateIds.add(id);
          }
        }
      }
    }

    // Include POV character contexts
    if (request.povCharacterId) {
      const povContexts = this.contextsByEntity.get(request.povCharacterId);
      if (povContexts) {
        for (const id of povContexts) {
          candidateIds.add(id);
        }
      }
    }

    // Include location contexts
    if (request.locationId) {
      const locContexts = this.contextsByEntity.get(request.locationId);
      if (locContexts) {
        for (const id of locContexts) {
          candidateIds.add(id);
        }
      }
    }

    // Include plot thread contexts
    if (request.plotThreadIds) {
      for (const threadId of request.plotThreadIds) {
        const threadContexts = this.contextsByEntity.get(threadId);
        if (threadContexts) {
          for (const id of threadContexts) {
            candidateIds.add(id);
          }
        }
      }
    }

    // Include chapter-specific contexts
    const chapterContexts = this.contextsByChapter.get(request.chapterNumber);
    if (chapterContexts) {
      for (const id of chapterContexts) {
        candidateIds.add(id);
      }
    }

    // Include explicitly requested contexts
    if (request.includeIds) {
      for (const id of request.includeIds) {
        candidateIds.add(id);
      }
    }

    return Array.from(candidateIds).map(id => this.contexts.get(id)!);
  }

  private rankContexts(contexts: ContextPiece[], request: ContextRequest): ContextPiece[] {
    return contexts.sort((a, b) => {
      // Priority first
      const priorityOrder = {
        [ContextPriority.CRITICAL]: 0,
        [ContextPriority.HIGH]: 1,
        [ContextPriority.MEDIUM]: 2,
        [ContextPriority.LOW]: 3,
        [ContextPriority.REFERENCE]: 4
      };

      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
      if (priorityDiff !== 0) return priorityDiff;

      // Then by relevance to POV character
      if (request.povCharacterId) {
        const aHasPov = a.relatedEntities.includes(request.povCharacterId);
        const bHasPov = b.relatedEntities.includes(request.povCharacterId);
        if (aHasPov && !bHasPov) return -1;
        if (bHasPov && !aHasPov) return 1;
      }

      // Then by recency (more recently updated first)
      return b.lastUpdated.getTime() - a.lastUpdated.getTime();
    });
  }

  private buildSection(pieces: ContextPiece[], types: ContextType[]): string {
    const relevant = pieces.filter(p => types.includes(p.type));
    if (relevant.length === 0) return '';

    return relevant.map(p => {
      const header = `### ${p.name}`;
      const content = p.priority === ContextPriority.CRITICAL ? p.content : p.summary || p.content;
      return `${header}\n${content}`;
    }).join('\n\n');
  }

  private buildSystemPrompt(request: ContextRequest, pieces: ContextPiece[]): string {
    const worldRules = pieces
      .filter(p => p.type === ContextType.WORLD_RULE && p.priority === ContextPriority.CRITICAL)
      .map(p => `- ${p.summary || p.content}`)
      .join('\n');

    return `You are a skilled fiction writer helping to write Chapter ${request.chapterNumber}.

CRITICAL WORLD RULES (never violate these):
${worldRules || '- Follow established canon'}

Your writing should:
- Maintain consistency with all established facts
- Keep character voices distinct and consistent
- Advance plot threads naturally
- Show, don't tell
- Match the established style and tone`;
  }

  // ==========================================================================
  // TEMPLATE MANAGEMENT
  // ==========================================================================

  addTemplate(template: ContextTemplate): void {
    this.templates.set(template.id, template);
  }

  getTemplate(id: string): ContextTemplate | undefined {
    return this.templates.get(id);
  }

  getAllTemplates(): ContextTemplate[] {
    return Array.from(this.templates.values());
  }

  applyTemplate(templateId: string, variables: Record<string, string>): string | null {
    const template = this.templates.get(templateId);
    if (!template) return null;

    let result = template.systemPromptTemplate;

    for (const [key, value] of Object.entries(variables)) {
      const placeholder = `{{${key}}}`;
      result = result.replace(new RegExp(placeholder, 'g'), value);
    }

    return result;
  }

  // ==========================================================================
  // WRITING SESSION MANAGEMENT
  // ==========================================================================

  startSession(chapterNumber: number, sceneIndex?: number): WritingSession {
    // Generate context for this session
    const context = this.generateContextForChapter({
      chapterNumber,
      sceneIndex
    });

    const session: WritingSession = {
      id: uuidv4(),
      chapterNumber,
      sceneIndex,
      startedAt: new Date(),
      contextBundleId: context.bundleId,
      promptsSent: [],
      responsesReceived: [],
      notes: '',
      status: 'active'
    };

    this.sessions.set(session.id, session);
    return session;
  }

  recordPrompt(sessionId: string, prompt: string, purpose: string): PromptRecord | null {
    const session = this.sessions.get(sessionId);
    if (!session) return null;

    const bundle = this.bundles.get(session.contextBundleId);

    const record: PromptRecord = {
      id: uuidv4(),
      timestamp: new Date(),
      prompt,
      contextIncluded: bundle?.pieces || [],
      tokenCount: this.estimateTokens(prompt),
      purpose
    };

    session.promptsSent.push(record);
    return record;
  }

  recordResponse(
    sessionId: string,
    promptId: string,
    response: string,
    accepted: boolean,
    edits?: string,
    notes?: string
  ): ResponseRecord | null {
    const session = this.sessions.get(sessionId);
    if (!session) return null;

    const record: ResponseRecord = {
      id: uuidv4(),
      promptId,
      timestamp: new Date(),
      response,
      tokenCount: this.estimateTokens(response),
      accepted,
      edits,
      notes
    };

    session.responsesReceived.push(record);
    return record;
  }

  endSession(sessionId: string, status: 'completed' | 'abandoned' = 'completed'): boolean {
    const session = this.sessions.get(sessionId);
    if (!session) return false;

    session.status = status;
    return true;
  }

  getSession(id: string): WritingSession | undefined {
    return this.sessions.get(id);
  }

  getActiveSessions(): WritingSession[] {
    return Array.from(this.sessions.values()).filter(s => s.status === 'active');
  }

  // ==========================================================================
  // BUNDLE MANAGEMENT
  // ==========================================================================

  createBundle(name: string, description: string, pieceIds: string[]): ContextBundle {
    const pieces = pieceIds
      .map(id => this.contexts.get(id))
      .filter((p): p is ContextPiece => p !== undefined);

    const totalTokens = pieces.reduce((sum, p) => sum + p.tokenEstimate, 0);

    const bundle: ContextBundle = {
      id: uuidv4(),
      name,
      description,
      pieces: pieceIds,
      totalTokens,
      autoGenerated: false,
      createdAt: new Date()
    };

    this.bundles.set(bundle.id, bundle);
    return bundle;
  }

  getBundle(id: string): ContextBundle | undefined {
    return this.bundles.get(id);
  }

  getBundleContent(bundleId: string): string {
    const bundle = this.bundles.get(bundleId);
    if (!bundle) return '';

    return bundle.pieces
      .map(id => this.contexts.get(id))
      .filter((p): p is ContextPiece => p !== undefined)
      .map(p => `## ${p.name}\n${p.content}`)
      .join('\n\n---\n\n');
  }

  // ==========================================================================
  // STATISTICS
  // ==========================================================================

  getStats(): {
    totalContexts: number;
    byType: Record<string, number>;
    byPriority: Record<string, number>;
    totalTokens: number;
    bundles: number;
    sessions: number;
    activeSessions: number;
    templates: number;
  } {
    const contexts = this.getAllContexts();

    const byType: Record<string, number> = {};
    const byPriority: Record<string, number> = {};
    let totalTokens = 0;

    for (const ctx of contexts) {
      byType[ctx.type] = (byType[ctx.type] || 0) + 1;
      byPriority[ctx.priority] = (byPriority[ctx.priority] || 0) + 1;
      totalTokens += ctx.tokenEstimate;
    }

    return {
      totalContexts: contexts.length,
      byType,
      byPriority,
      totalTokens,
      bundles: this.bundles.size,
      sessions: this.sessions.size,
      activeSessions: this.getActiveSessions().length,
      templates: this.templates.size
    };
  }

  // ==========================================================================
  // EXPORT/IMPORT
  // ==========================================================================

  exportToJSON(): string {
    return JSON.stringify({
      contexts: Array.from(this.contexts.values()),
      bundles: Array.from(this.bundles.values()),
      templates: Array.from(this.templates.values()).filter(t =>
        !['standard-chapter', 'dialogue-scene', 'action-scene', 'introspective-scene'].includes(t.id)
      ),
      sessions: Array.from(this.sessions.values())
    }, null, 2);
  }

  importFromJSON(json: string): void {
    const data = JSON.parse(json);

    if (data.contexts) {
      for (const ctx of data.contexts) {
        ctx.lastUpdated = new Date(ctx.lastUpdated);
        this.contexts.set(ctx.id, ctx);
        this.indexContext(ctx);
      }
    }

    if (data.bundles) {
      for (const bundle of data.bundles) {
        bundle.createdAt = new Date(bundle.createdAt);
        this.bundles.set(bundle.id, bundle);
      }
    }

    if (data.templates) {
      for (const template of data.templates) {
        this.templates.set(template.id, template);
      }
    }

    if (data.sessions) {
      for (const session of data.sessions) {
        session.startedAt = new Date(session.startedAt);
        this.sessions.set(session.id, session);
      }
    }
  }

  // ==========================================================================
  // CLEAR
  // ==========================================================================

  clear(): void {
    this.contexts.clear();
    this.bundles.clear();
    this.sessions.clear();
    this.contextsByType.clear();
    this.contextsByEntity.clear();
    this.contextsByChapter.clear();
    this.contextsByTag.clear();
  }
}

// Export singleton instance
export const contextManager = new ContextManager();

export default ContextManager;
