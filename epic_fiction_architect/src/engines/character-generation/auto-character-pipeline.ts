/**
 * AutoCharacterPipeline - Cascading World-Building from Character Creation
 *
 * When a character is created, this engine automatically:
 * 1. Generates their complete backstory/history
 * 2. Creates connected characters (family, mentors, rivals, friends)
 * 3. Generates locations (birthplace, important places)
 * 4. Assigns culture, species, powers, factions
 * 5. Registers with ripple/cascade engines
 * 6. Expands the fandom/universe context
 *
 * Designed for 300M+ word narratives with 80+ characters across 1,000 years
 */

import { v4 as uuidv4 } from 'uuid';

// ============================================================================
// Core Enums
// ============================================================================

export enum CharacterOriginType {
  CANON = 'canon',                    // From source material
  CANON_VARIANT = 'canon_variant',    // Canon with alterations
  ORIGINAL = 'original',              // Created for this story
  GENERATED = 'generated',            // Auto-generated by pipeline
  IMPORTED = 'imported',              // From another jump/universe
  COMPOSITE = 'composite',            // Merged from multiple sources
}

export enum GenerationDepth {
  MINIMAL = 'minimal',       // Just the character, no cascade
  SHALLOW = 'shallow',       // Immediate family only
  MODERATE = 'moderate',     // Family + close connections
  DEEP = 'deep',             // Full social network
  EXHAUSTIVE = 'exhaustive', // Complete world expansion
}

export enum RelationshipCategory {
  FAMILY = 'family',
  ROMANTIC = 'romantic',
  FRIENDSHIP = 'friendship',
  PROFESSIONAL = 'professional',
  RIVALRY = 'rivalry',
  MENTORSHIP = 'mentorship',
  POLITICAL = 'political',
  SPIRITUAL = 'spiritual',
}

export enum FamilyRelationType {
  PARENT = 'parent',
  CHILD = 'child',
  SIBLING = 'sibling',
  GRANDPARENT = 'grandparent',
  GRANDCHILD = 'grandchild',
  AUNT_UNCLE = 'aunt_uncle',
  NIECE_NEPHEW = 'niece_nephew',
  COUSIN = 'cousin',
  SPOUSE = 'spouse',
  EX_SPOUSE = 'ex_spouse',
  STEP_PARENT = 'step_parent',
  STEP_SIBLING = 'step_sibling',
  ADOPTIVE_PARENT = 'adoptive_parent',
  ADOPTIVE_CHILD = 'adoptive_child',
  GODPARENT = 'godparent',
  IN_LAW = 'in_law',
}

export enum LifeEventType {
  BIRTH = 'birth',
  DEATH = 'death',
  MARRIAGE = 'marriage',
  DIVORCE = 'divorce',
  GRADUATION = 'graduation',
  FIRST_JOB = 'first_job',
  PROMOTION = 'promotion',
  INJURY = 'injury',
  ILLNESS = 'illness',
  RECOVERY = 'recovery',
  TRAUMA = 'trauma',
  ACHIEVEMENT = 'achievement',
  FAILURE = 'failure',
  DISCOVERY = 'discovery',
  POWER_AWAKENING = 'power_awakening',
  TRAINING_START = 'training_start',
  TRAINING_COMPLETE = 'training_complete',
  FIRST_KILL = 'first_kill',
  FIRST_LOVE = 'first_love',
  HEARTBREAK = 'heartbreak',
  BETRAYAL_RECEIVED = 'betrayal_received',
  BETRAYAL_COMMITTED = 'betrayal_committed',
  TRAVEL = 'travel',
  RELOCATION = 'relocation',
  IMPRISONMENT = 'imprisonment',
  ESCAPE = 'escape',
  REVELATION = 'revelation',
  TRANSFORMATION = 'transformation',
  FACTION_JOIN = 'faction_join',
  FACTION_LEAVE = 'faction_leave',
  INHERITANCE = 'inheritance',
  LOSS = 'loss',
  REUNION = 'reunion',
  SEPARATION = 'separation',
}

export enum LocationImportance {
  BIRTHPLACE = 'birthplace',
  CHILDHOOD_HOME = 'childhood_home',
  TRAINING_GROUND = 'training_ground',
  WORKPLACE = 'workplace',
  CURRENT_RESIDENCE = 'current_residence',
  SIGNIFICANT_MEMORY = 'significant_memory',
  TRAUMA_SITE = 'trauma_site',
  ACHIEVEMENT_SITE = 'achievement_site',
  MEETING_PLACE = 'meeting_place',
  HIDEOUT = 'hideout',
  PILGRIMAGE_SITE = 'pilgrimage_site',
}

// ============================================================================
// Universe/Fandom Context
// ============================================================================

export interface UniverseContext {
  universeId: string;
  universeName: string;
  canonSource: string;

  // Time period in the universe
  currentEra: string;
  yearInUniverse?: number | string;

  // Major factions/groups
  majorFactions: FactionTemplate[];

  // Power systems available
  powerSystems: string[]; // IDs to MagicSystemDesigner

  // Cultural defaults
  defaultCultures: CultureTemplate[];

  // Species available
  availableSpecies: SpeciesTemplate[];

  // Geographic context
  majorLocations: LocationTemplate[];

  // Canon characters that can be referenced
  canonCharacters: CanonCharacterReference[];

  // Universe-specific rules
  universeRules: string[];

  // Typical naming conventions
  namingConventions: NamingConvention[];
}

export interface FactionTemplate {
  factionId: string;
  factionName: string;
  description: string;
  alignment: 'protagonist' | 'antagonist' | 'neutral' | 'variable';
  powerLevel: 'minor' | 'moderate' | 'major' | 'dominant';
  joinRequirements?: string[];
  typicalRoles: string[];
  rivals: string[];
  allies: string[];
}

export interface CultureTemplate {
  cultureId: string;
  cultureName: string;
  description: string;
  values: string[];
  traditions: string[];
  typicalOccupations: string[];
  familyStructure: 'nuclear' | 'extended' | 'clan' | 'communal' | 'other';
  namingConventionId?: string;
}

export interface SpeciesTemplate {
  speciesId: string;
  speciesName: string;
  description: string;
  lifespan: { min: number; typical: number; max: number };
  maturityAge: number;
  physicalTraits: string[];
  innateAbilities?: string[];
  weaknesses?: string[];
  cultures?: string[]; // Culture IDs typical for this species
}

export interface LocationTemplate {
  locationId: string;
  locationName: string;
  locationType: 'city' | 'village' | 'region' | 'country' | 'continent' | 'world' | 'dimension' | 'other';
  description: string;
  population?: number | string;
  dominantFaction?: string;
  dominantCulture?: string;
  climate?: string;
  notableFeatures: string[];
}

export interface CanonCharacterReference {
  characterId: string;
  characterName: string;
  role: 'protagonist' | 'antagonist' | 'supporting' | 'minor';
  status: 'alive' | 'dead' | 'unknown' | 'variable';
  faction?: string;
  notableRelationships: { characterName: string; relationship: string }[];
  canBeParent: boolean;
  canBeMentor: boolean;
  canBeRival: boolean;
}

export interface NamingConvention {
  conventionId: string;
  cultureName: string;
  format: string; // e.g., "{given} {family}", "{family} {given}", "{given} of {location}"
  givenNamePatterns: string[];
  familyNamePatterns: string[];
  titlePatterns?: string[];
  examples: string[];
}

// ============================================================================
// Character Generation Request
// ============================================================================

export interface CharacterGenerationRequest {
  requestId: string;
  createdAt: Date;

  // Basic info (can be partial - pipeline fills in gaps)
  name?: string;
  aliases?: string[];

  // Origin
  originType: CharacterOriginType;
  canonSource?: string;
  canonCharacterRef?: string; // If based on canon character

  // Universe context
  universeId: string;

  // Generation parameters
  generationDepth: GenerationDepth;
  maxCascadeDepth: number; // How many relationship levels deep to generate

  // Constraints
  constraints: {
    species?: string;
    culture?: string;
    faction?: string;
    ageRange?: { min: number; max: number };
    gender?: string;
    alignment?: 'good' | 'neutral' | 'evil' | 'complex';
    powerLevel?: 'none' | 'low' | 'medium' | 'high' | 'extreme';
    socialClass?: 'lower' | 'middle' | 'upper' | 'noble' | 'royal' | 'outcast';
    mustHaveRelationships?: { type: FamilyRelationType; toCharacterId?: string }[];
    mustHavePowers?: string[];
    mustBelongToFaction?: string;
    mustLiveIn?: string;
    mustHaveOccupation?: string;
  };

  // Backstory parameters
  backstoryParams: {
    includeChildhood: boolean;
    includeTrauma: boolean;
    includeRomance: boolean;
    includeAchievements: boolean;
    minLifeEvents: number;
    maxLifeEvents: number;
    timelineStartYear?: number;
    currentAge?: number;
  };

  // What to generate
  generateOptions: {
    generateFamily: boolean;
    generateMentor: boolean;
    generateRivals: boolean;
    generateFriends: boolean;
    generateLocations: boolean;
    generatePowers: boolean;
    generateFactionMembership: boolean;
    expandUniverseContext: boolean;
  };

  // Narrative role
  narrativeRole?: 'protagonist' | 'antagonist' | 'supporting' | 'minor' | 'background';
  storySignificance?: 'critical' | 'major' | 'moderate' | 'minor';
}

// ============================================================================
// Generated Character
// ============================================================================

export interface GeneratedCharacter {
  characterId: string;
  generatedAt: Date;
  requestId: string;

  // Basic info
  name: string;
  aliases: string[];
  title?: string;

  // Origin
  originType: CharacterOriginType;
  canonSource?: string;
  divergenceFromCanon?: string;

  // Demographics
  species: string;
  speciesDetails?: SpeciesTemplate;
  culture: string;
  cultureDetails?: CultureTemplate;
  gender: string;
  birthDate: GeneratedDate;
  deathDate?: GeneratedDate;
  currentAge: number;

  // Physical
  appearance: {
    height: string;
    build: string;
    hairColor: string;
    eyeColor: string;
    skinTone: string;
    distinguishingFeatures: string[];
    style: string;
  };

  // Personality
  personality: {
    coreTraits: string[];
    strengths: string[];
    weaknesses: string[];
    fears: string[];
    desires: string[];
    values: string[];
    quirks: string[];
    alignment: string;
  };

  // Background
  background: {
    birthplace: string;
    birthplaceLocationId?: string;
    childhoodSummary: string;
    education: string;
    occupation: string;
    socialClass: string;
    wealth: 'destitute' | 'poor' | 'modest' | 'comfortable' | 'wealthy' | 'rich' | 'vast';
    fullHistory: string; // Synthesized narrative
  };

  // Relationships (IDs to other generated characters)
  relationships: GeneratedRelationship[];

  // Locations
  significantLocations: GeneratedLocation[];
  currentLocationId?: string;

  // Powers
  powers: GeneratedPower[];
  powerSystemIds: string[];

  // Factions
  factions: GeneratedFactionMembership[];

  // Life events (timeline)
  lifeEvents: GeneratedLifeEvent[];

  // Voice profile for writing
  voiceProfile: {
    vocabularyLevel: 'simple' | 'moderate' | 'sophisticated' | 'archaic' | 'technical';
    speechPatterns: string[];
    favoredExpressions: string[];
    accent?: string;
    internalVoiceTone: string;
  };

  // Narrative
  narrativeRole: string;
  storySignificance: string;
  characterArcPotential: string[];
  plotHooks: string[];

  // Cascade tracking
  generatedFrom?: string; // Parent character ID if cascaded
  cascadeDepth: number;
  triggeredGenerations: string[]; // IDs of characters generated because of this one
}

export interface GeneratedDate {
  year: number;
  month?: number;
  day?: number;
  era?: string;
  displayFormat: string;
}

export interface GeneratedRelationship {
  relationshipId: string;
  targetCharacterId: string;
  targetCharacterName: string;
  category: RelationshipCategory;
  specificType: string; // e.g., "mother", "rival", "mentor"
  familyRelationType?: FamilyRelationType;
  sentiment: 'love' | 'like' | 'neutral' | 'dislike' | 'hate' | 'complex';
  intensity: number; // 0-1
  startYear?: number;
  endYear?: number;
  notes: string;
  isGenerated: boolean; // Was this character generated by the pipeline?
}

export interface GeneratedLocation {
  locationId: string;
  locationName: string;
  importance: LocationImportance;
  description: string;
  yearsPresent?: { from: number; to?: number };
  significantEvents: string[];
  isGenerated: boolean;
}

export interface GeneratedPower {
  powerId: string;
  powerName: string;
  systemId: string;
  systemName: string;
  acquisitionAge?: number;
  acquisitionEvent?: string;
  proficiency: number; // 0-100
  notes: string;
}

export interface GeneratedFactionMembership {
  factionId: string;
  factionName: string;
  role: string;
  rank?: string;
  joinedYear?: number;
  leftYear?: number;
  status: 'active' | 'inactive' | 'expelled' | 'defected' | 'deceased';
  loyaltyLevel: number; // 0-1
  notes: string;
}

export interface GeneratedLifeEvent {
  eventId: string;
  eventType: LifeEventType;
  year: number;
  age: number;
  title: string;
  description: string;
  emotionalImpact: number; // -1 to 1
  involvedCharacterIds: string[];
  locationId?: string;
  consequences: string[];
  isPublicKnowledge: boolean;
}

// ============================================================================
// Generation Result
// ============================================================================

export interface GenerationResult {
  resultId: string;
  requestId: string;
  completedAt: Date;

  // Primary character
  primaryCharacter: GeneratedCharacter;

  // Cascaded generations
  generatedCharacters: GeneratedCharacter[];
  generatedLocations: GeneratedLocation[];

  // Statistics
  stats: {
    totalCharactersGenerated: number;
    totalLocationsGenerated: number;
    totalRelationshipsCreated: number;
    totalLifeEventsGenerated: number;
    maxCascadeDepthReached: number;
    generationTimeMs: number;
  };

  // Universe expansion
  universeExpansions: {
    newFactions: FactionTemplate[];
    newLocations: LocationTemplate[];
    newCultures: CultureTemplate[];
    newCanonReferences: CanonCharacterReference[];
  };

  // Warnings and notes
  warnings: string[];
  notes: string[];
}

// ============================================================================
// Family Tree Structure
// ============================================================================

export interface FamilyTree {
  treeId: string;
  rootCharacterId: string;

  members: Map<string, FamilyMember>;
  generations: Map<number, string[]>; // Generation number -> character IDs

  // Family-wide traits
  familyName: string;
  familyOrigin: string;
  familyTraits: string[]; // Inherited traits
  familySecrets: string[];
  familyWealth: string;
  familyReputation: string;

  // Lineage
  bloodlineAbilities?: string[];
  curses?: string[];
  prophecies?: string[];
}

export interface FamilyMember {
  characterId: string;
  characterName: string;
  generation: number; // 0 = root, negative = ancestors, positive = descendants
  birthOrder?: number; // Among siblings
  isAlive: boolean;
  relationships: {
    parents: string[];
    children: string[];
    siblings: string[];
    spouses: string[];
  };
}

// ============================================================================
// Backstory Templates
// ============================================================================

export interface BackstoryTemplate {
  templateId: string;
  templateName: string;
  archetypeMatch: string[]; // Character archetypes this fits

  // Life phases
  childhoodTemplate: string;
  adolescenceTemplate: string;
  adulthoodTemplate: string;

  // Required events
  requiredEventTypes: LifeEventType[];

  // Typical trajectory
  typicalTrajectory: {
    age: number;
    eventType: LifeEventType;
    description: string;
  }[];

  // Narrative hooks
  builtInHooks: string[];
}

const DEFAULT_BACKSTORY_TEMPLATES: BackstoryTemplate[] = [
  {
    templateId: 'orphan-hero',
    templateName: 'Orphan Hero',
    archetypeMatch: ['hero', 'chosen_one', 'underdog'],
    childhoodTemplate: 'Lost parents at young age, raised by {caretaker} in {location}. Struggled with {challenge} but found solace in {activity}.',
    adolescenceTemplate: 'Discovered {ability/truth} at age {age}. Left {location} to pursue {goal}. Met {mentor} who taught {lesson}.',
    adulthoodTemplate: 'Now known as {title}, {character} seeks to {goal} while haunted by {past_event}.',
    requiredEventTypes: [LifeEventType.DEATH, LifeEventType.DISCOVERY, LifeEventType.TRAINING_START],
    typicalTrajectory: [
      { age: 3, eventType: LifeEventType.TRAUMA, description: 'Loss of parents' },
      { age: 12, eventType: LifeEventType.DISCOVERY, description: 'Discovers hidden ability or truth' },
      { age: 14, eventType: LifeEventType.TRAINING_START, description: 'Begins training' },
      { age: 18, eventType: LifeEventType.FIRST_KILL, description: 'First major conflict' },
    ],
    builtInHooks: ['mystery of parents\' death', 'hidden heritage', 'prophesied destiny'],
  },
  {
    templateId: 'fallen-noble',
    templateName: 'Fallen Noble',
    archetypeMatch: ['anti_hero', 'redeemer', 'exile'],
    childhoodTemplate: 'Born to the {family_name} family, enjoyed privilege in {location}. Trained in {skills} from age {age}.',
    adolescenceTemplate: 'Family fell from grace due to {event}. Lost {possessions/status}. Forced to {survival_method}.',
    adulthoodTemplate: 'Now {current_status}, {character} walks the line between {old_values} and {new_reality}.',
    requiredEventTypes: [LifeEventType.LOSS, LifeEventType.BETRAYAL_RECEIVED, LifeEventType.RELOCATION],
    typicalTrajectory: [
      { age: 0, eventType: LifeEventType.BIRTH, description: 'Born to noble family' },
      { age: 16, eventType: LifeEventType.BETRAYAL_RECEIVED, description: 'Family betrayed' },
      { age: 16, eventType: LifeEventType.LOSS, description: 'Loses status and wealth' },
      { age: 17, eventType: LifeEventType.RELOCATION, description: 'Forced to flee' },
    ],
    builtInHooks: ['restore family honor', 'revenge against betrayers', 'reclaim birthright'],
  },
  {
    templateId: 'self-made',
    templateName: 'Self-Made Success',
    archetypeMatch: ['achiever', 'mentor', 'leader'],
    childhoodTemplate: 'Born to {humble_origin} in {location}. Showed early aptitude for {skill}. Dreamed of {ambition}.',
    adolescenceTemplate: 'Worked tirelessly at {job/training}. Caught the attention of {patron/mentor}. Achieved {first_success}.',
    adulthoodTemplate: 'Rose to become {position}. Known for {reputation}. Now faces {current_challenge}.',
    requiredEventTypes: [LifeEventType.ACHIEVEMENT, LifeEventType.PROMOTION, LifeEventType.FIRST_JOB],
    typicalTrajectory: [
      { age: 8, eventType: LifeEventType.DISCOVERY, description: 'Discovers natural talent' },
      { age: 14, eventType: LifeEventType.FIRST_JOB, description: 'Begins working/training' },
      { age: 20, eventType: LifeEventType.ACHIEVEMENT, description: 'First major success' },
      { age: 25, eventType: LifeEventType.PROMOTION, description: 'Rises to prominence' },
    ],
    builtInHooks: ['maintaining success', 'enemies from the climb', 'mentoring the next generation'],
  },
];

// ============================================================================
// Main Pipeline Engine
// ============================================================================

export class AutoCharacterPipeline {
  private universes: Map<string, UniverseContext> = new Map();
  private generatedCharacters: Map<string, GeneratedCharacter> = new Map();
  private familyTrees: Map<string, FamilyTree> = new Map();
  private generatedLocations: Map<string, GeneratedLocation> = new Map();
  private backstoryTemplates: Map<string, BackstoryTemplate> = new Map();
  private namingConventions: Map<string, NamingConvention> = new Map();

  // Generation queue for cascade (reserved for batch processing)
  private generationQueue: CharacterGenerationRequest[] = [];
  private processingResults: GenerationResult[] = [];

  // Indexes
  private charactersByUniverse: Map<string, string[]> = new Map();
  private charactersByFaction: Map<string, string[]> = new Map();
  private charactersByLocation: Map<string, string[]> = new Map();
  private charactersByFamily: Map<string, string[]> = new Map();

  // Statistics
  private totalGenerations: number = 0;
  private totalCascades: number = 0;

  constructor() {
    this.initializeDefaultTemplates();
    // Initialize queue (used for batch processing)
    void this.generationQueue;
  }

  private initializeDefaultTemplates(): void {
    for (const template of DEFAULT_BACKSTORY_TEMPLATES) {
      this.backstoryTemplates.set(template.templateId, template);
    }
  }

  // ============================================================================
  // Universe Management
  // ============================================================================

  registerUniverse(universe: UniverseContext): void {
    this.universes.set(universe.universeId, universe);
    this.charactersByUniverse.set(universe.universeId, []);

    // Register naming conventions
    for (const convention of universe.namingConventions) {
      this.namingConventions.set(convention.conventionId, convention);
    }
  }

  getUniverse(universeId: string): UniverseContext | undefined {
    return this.universes.get(universeId);
  }

  // Create common universe templates
  createUniverseTemplate(
    template: 'naruto' | 'harry_potter' | 'marvel' | 'dc' | 'warhammer_40k' | 'star_wars' | 'generic_fantasy' | 'generic_scifi'
  ): UniverseContext {
    switch (template) {
      case 'naruto':
        return {
          universeId: uuidv4(),
          universeName: 'Naruto',
          canonSource: 'Naruto/Boruto manga and anime',
          currentEra: 'Fourth Great Ninja War Era',
          majorFactions: [
            { factionId: uuidv4(), factionName: 'Konohagakure', description: 'Hidden Leaf Village', alignment: 'protagonist', powerLevel: 'dominant', typicalRoles: ['ninja', 'chunin', 'jonin', 'ANBU'], rivals: [], allies: [] },
            { factionId: uuidv4(), factionName: 'Akatsuki', description: 'Criminal organization of S-rank missing-nin', alignment: 'antagonist', powerLevel: 'major', typicalRoles: ['missing-nin', 'S-rank criminal'], rivals: [], allies: [] },
          ],
          powerSystems: ['chakra_system'],
          defaultCultures: [
            { cultureId: uuidv4(), cultureName: 'Konoha Shinobi', description: 'Will of Fire believers', values: ['loyalty', 'friendship', 'perseverance'], traditions: ['Chunin Exams', 'Will of Fire'], typicalOccupations: ['ninja', 'merchant', 'craftsman'], familyStructure: 'nuclear' },
          ],
          availableSpecies: [
            { speciesId: uuidv4(), speciesName: 'Human', description: 'Standard human', lifespan: { min: 60, typical: 75, max: 100 }, maturityAge: 18, physicalTraits: ['varies'] },
          ],
          majorLocations: [
            { locationId: uuidv4(), locationName: 'Konohagakure', locationType: 'city', description: 'Hidden Leaf Village', population: '80,000', notableFeatures: ['Hokage Rock', 'Academy', 'Hospital'] },
          ],
          canonCharacters: [
            { characterId: 'naruto', characterName: 'Naruto Uzumaki', role: 'protagonist', status: 'alive', notableRelationships: [{ characterName: 'Sasuke', relationship: 'rival/friend' }], canBeParent: true, canBeMentor: true, canBeRival: true },
          ],
          universeRules: ['Chakra is required for jutsu', 'Hand seals focus chakra', 'Bloodline limits are inherited'],
          namingConventions: [
            { conventionId: uuidv4(), cultureName: 'Konoha', format: '{given} {family}', givenNamePatterns: ['Japanese-inspired'], familyNamePatterns: ['Clan names'], examples: ['Naruto Uzumaki', 'Sakura Haruno', 'Sasuke Uchiha'] },
          ],
        };

      case 'generic_fantasy':
        return {
          universeId: uuidv4(),
          universeName: 'Generic Fantasy World',
          canonSource: 'Original',
          currentEra: 'Age of Heroes',
          majorFactions: [
            { factionId: uuidv4(), factionName: 'The Kingdom', description: 'Human kingdom', alignment: 'neutral', powerLevel: 'dominant', typicalRoles: ['knight', 'mage', 'noble', 'peasant'], rivals: [], allies: [] },
            { factionId: uuidv4(), factionName: 'The Dark Lord\'s Forces', description: 'Evil army', alignment: 'antagonist', powerLevel: 'major', typicalRoles: ['dark knight', 'necromancer', 'orc'], rivals: [], allies: [] },
          ],
          powerSystems: ['arcane_magic', 'divine_magic'],
          defaultCultures: [
            { cultureId: uuidv4(), cultureName: 'Kingdom Human', description: 'Medieval European inspired', values: ['honor', 'duty', 'faith'], traditions: ['Knighting ceremonies', 'Harvest festivals'], typicalOccupations: ['farmer', 'blacksmith', 'soldier', 'merchant'], familyStructure: 'nuclear' },
          ],
          availableSpecies: [
            { speciesId: uuidv4(), speciesName: 'Human', description: 'Standard human', lifespan: { min: 50, typical: 70, max: 100 }, maturityAge: 18, physicalTraits: ['varies'] },
            { speciesId: uuidv4(), speciesName: 'Elf', description: 'Long-lived, graceful beings', lifespan: { min: 500, typical: 750, max: 1200 }, maturityAge: 100, physicalTraits: ['pointed ears', 'slender', 'graceful'], innateAbilities: ['low-light vision', 'magic affinity'] },
            { speciesId: uuidv4(), speciesName: 'Dwarf', description: 'Stout, hardy mountain folk', lifespan: { min: 200, typical: 350, max: 500 }, maturityAge: 50, physicalTraits: ['short', 'stocky', 'bearded'], innateAbilities: ['darkvision', 'poison resistance'] },
          ],
          majorLocations: [
            { locationId: uuidv4(), locationName: 'Capital City', locationType: 'city', description: 'Heart of the kingdom', population: '100,000', notableFeatures: ['Royal Castle', 'Grand Temple', 'Mage Tower'] },
          ],
          canonCharacters: [],
          universeRules: ['Magic requires mana', 'Divine magic requires faith', 'Iron disrupts fae magic'],
          namingConventions: [
            { conventionId: uuidv4(), cultureName: 'Human', format: '{given} {family}', givenNamePatterns: ['Medieval European'], familyNamePatterns: ['Occupation-based', 'Location-based'], examples: ['John Smith', 'Eleanor of Westmarch'] },
          ],
        };

      default:
        throw new Error(`Unknown universe template: ${template}`);
    }
  }

  // ============================================================================
  // Main Generation Pipeline
  // ============================================================================

  async generateCharacter(request: CharacterGenerationRequest): Promise<GenerationResult> {
    const startTime = Date.now();
    const resultId = uuidv4();

    // Validate universe exists
    const universe = this.universes.get(request.universeId);
    if (!universe) {
      throw new Error(`Universe not found: ${request.universeId}. Register universe first.`);
    }

    // Generate primary character
    const primaryCharacter = await this.generateSingleCharacter(request, universe, 0);

    // Track all generated entities
    const generatedCharacters: GeneratedCharacter[] = [primaryCharacter];
    const generatedLocations: GeneratedLocation[] = [...primaryCharacter.significantLocations.filter(l => l.isGenerated)];

    // Cascade generation based on depth
    if (request.generationDepth !== GenerationDepth.MINIMAL) {
      const cascadeResults = await this.cascadeGeneration(
        primaryCharacter,
        request,
        universe
      );

      generatedCharacters.push(...cascadeResults.characters);
      generatedLocations.push(...cascadeResults.locations);
    }

    // Build result
    const result: GenerationResult = {
      resultId,
      requestId: request.requestId,
      completedAt: new Date(),
      primaryCharacter,
      generatedCharacters: generatedCharacters.slice(1), // Exclude primary
      generatedLocations,
      stats: {
        totalCharactersGenerated: generatedCharacters.length,
        totalLocationsGenerated: generatedLocations.length,
        totalRelationshipsCreated: generatedCharacters.reduce((sum, c) => sum + c.relationships.length, 0),
        totalLifeEventsGenerated: generatedCharacters.reduce((sum, c) => sum + c.lifeEvents.length, 0),
        maxCascadeDepthReached: Math.max(...generatedCharacters.map(c => c.cascadeDepth)),
        generationTimeMs: Date.now() - startTime,
      },
      universeExpansions: {
        newFactions: [],
        newLocations: [],
        newCultures: [],
        newCanonReferences: [],
      },
      warnings: [],
      notes: [],
    };

    this.processingResults.push(result);
    this.totalGenerations++;

    return result;
  }

  private async generateSingleCharacter(
    request: CharacterGenerationRequest,
    universe: UniverseContext,
    cascadeDepth: number
  ): Promise<GeneratedCharacter> {
    const characterId = uuidv4();

    // Determine species
    const species = this.selectSpecies(request, universe);

    // Determine culture
    const culture = this.selectCulture(request, universe, species);

    // Generate name if not provided
    const name = request.name || this.generateName(culture, universe);

    // Calculate age
    const age = this.calculateAge(request, species);
    const birthYear = this.calculateBirthYear(age, universe);

    // Generate appearance
    const appearance = this.generateAppearance(request, species, culture);

    // Generate personality
    const personality = this.generatePersonality(request, culture);

    // Generate backstory and life events
    const { background, lifeEvents } = await this.generateBackstory(
      request,
      name,
      species,
      culture,
      age,
      birthYear,
      universe
    );

    // Generate locations
    const significantLocations = this.generateLocations(
      request,
      background,
      lifeEvents,
      universe
    );

    // Generate powers
    const powers = this.generatePowers(request, species, culture, universe);

    // Generate faction memberships
    const factions = this.generateFactionMemberships(request, culture, universe);

    // Generate voice profile
    const voiceProfile = this.generateVoiceProfile(culture, personality);

    // Build character
    const character: GeneratedCharacter = {
      characterId,
      generatedAt: new Date(),
      requestId: request.requestId,
      name,
      aliases: request.aliases || [],
      originType: request.originType,
      canonSource: request.canonSource,
      species: species.speciesName,
      speciesDetails: species,
      culture: culture.cultureName,
      cultureDetails: culture,
      gender: request.constraints.gender || this.randomGender(),
      birthDate: {
        year: birthYear,
        displayFormat: `Year ${birthYear}`,
      },
      currentAge: age,
      appearance,
      personality,
      background,
      relationships: [], // Will be populated by cascade
      significantLocations,
      powers,
      powerSystemIds: powers.map(p => p.systemId),
      factions,
      lifeEvents,
      voiceProfile,
      narrativeRole: request.narrativeRole || 'supporting',
      storySignificance: request.storySignificance || 'moderate',
      characterArcPotential: this.identifyArcPotential(personality, background, lifeEvents),
      plotHooks: this.identifyPlotHooks(background, lifeEvents, factions),
      cascadeDepth,
      triggeredGenerations: [],
    };

    // Store character
    this.generatedCharacters.set(characterId, character);

    // Update indexes
    if (!this.charactersByUniverse.has(request.universeId)) {
      this.charactersByUniverse.set(request.universeId, []);
    }
    this.charactersByUniverse.get(request.universeId)!.push(characterId);

    for (const faction of factions) {
      if (!this.charactersByFaction.has(faction.factionId)) {
        this.charactersByFaction.set(faction.factionId, []);
      }
      this.charactersByFaction.get(faction.factionId)!.push(characterId);
    }

    return character;
  }

  // ============================================================================
  // Cascade Generation
  // ============================================================================

  private async cascadeGeneration(
    primaryCharacter: GeneratedCharacter,
    request: CharacterGenerationRequest,
    universe: UniverseContext
  ): Promise<{ characters: GeneratedCharacter[]; locations: GeneratedLocation[] }> {
    const generatedCharacters: GeneratedCharacter[] = [];
    const generatedLocations: GeneratedLocation[] = [];

    const maxDepth = request.maxCascadeDepth || this.getDefaultCascadeDepth(request.generationDepth);

    // Generate family if requested
    if (request.generateOptions.generateFamily) {
      const familyResult = await this.generateFamily(primaryCharacter, request, universe, maxDepth);
      generatedCharacters.push(...familyResult.characters);
      primaryCharacter.relationships.push(...familyResult.relationships);

      // Create family tree
      const familyTree = this.buildFamilyTree(primaryCharacter, familyResult.characters);
      this.familyTrees.set(familyTree.treeId, familyTree);
    }

    // Generate mentor if requested
    if (request.generateOptions.generateMentor) {
      const mentor = await this.generateMentor(primaryCharacter, request, universe);
      if (mentor) {
        generatedCharacters.push(mentor);
        primaryCharacter.relationships.push({
          relationshipId: uuidv4(),
          targetCharacterId: mentor.characterId,
          targetCharacterName: mentor.name,
          category: RelationshipCategory.MENTORSHIP,
          specificType: 'mentor',
          sentiment: 'like',
          intensity: 0.8,
          notes: `${mentor.name} trained ${primaryCharacter.name}`,
          isGenerated: true,
        });
      }
    }

    // Generate rivals if requested
    if (request.generateOptions.generateRivals) {
      const rivals = await this.generateRivals(primaryCharacter, request, universe);
      generatedCharacters.push(...rivals);
      for (const rival of rivals) {
        primaryCharacter.relationships.push({
          relationshipId: uuidv4(),
          targetCharacterId: rival.characterId,
          targetCharacterName: rival.name,
          category: RelationshipCategory.RIVALRY,
          specificType: 'rival',
          sentiment: 'complex',
          intensity: 0.7,
          notes: `Competitive relationship with ${rival.name}`,
          isGenerated: true,
        });
      }
    }

    // Generate friends if requested
    if (request.generateOptions.generateFriends) {
      const friends = await this.generateFriends(primaryCharacter, request, universe);
      generatedCharacters.push(...friends);
      for (const friend of friends) {
        primaryCharacter.relationships.push({
          relationshipId: uuidv4(),
          targetCharacterId: friend.characterId,
          targetCharacterName: friend.name,
          category: RelationshipCategory.FRIENDSHIP,
          specificType: 'friend',
          sentiment: 'like',
          intensity: 0.6,
          notes: `Friends since ${friend.lifeEvents[0]?.title || 'unknown circumstances'}`,
          isGenerated: true,
        });
      }
    }

    this.totalCascades += generatedCharacters.length;

    return { characters: generatedCharacters, locations: generatedLocations };
  }

  private getDefaultCascadeDepth(depth: GenerationDepth): number {
    const depths: Record<GenerationDepth, number> = {
      [GenerationDepth.MINIMAL]: 0,
      [GenerationDepth.SHALLOW]: 1,
      [GenerationDepth.MODERATE]: 2,
      [GenerationDepth.DEEP]: 3,
      [GenerationDepth.EXHAUSTIVE]: 5,
    };
    return depths[depth];
  }

  // ============================================================================
  // Family Generation
  // ============================================================================

  private async generateFamily(
    character: GeneratedCharacter,
    request: CharacterGenerationRequest,
    universe: UniverseContext,
    maxDepth: number
  ): Promise<{ characters: GeneratedCharacter[]; relationships: GeneratedRelationship[] }> {
    const familyMembers: GeneratedCharacter[] = [];
    const relationships: GeneratedRelationship[] = [];

    // Determine family structure based on culture
    const familyStructure = character.cultureDetails?.familyStructure || 'nuclear';

    // Generate parents (if not at max depth)
    if (maxDepth > 0) {
      // Mother
      const motherRequest = this.createFamilyMemberRequest(request, universe, {
        gender: 'female',
        ageOffset: 20 + Math.floor(Math.random() * 15), // 20-35 years older
        relationToOriginal: 'parent',
      });
      const mother = await this.generateSingleCharacter(motherRequest, universe, character.cascadeDepth + 1);
      mother.generatedFrom = character.characterId;
      familyMembers.push(mother);

      relationships.push({
        relationshipId: uuidv4(),
        targetCharacterId: mother.characterId,
        targetCharacterName: mother.name,
        category: RelationshipCategory.FAMILY,
        specificType: 'mother',
        familyRelationType: FamilyRelationType.PARENT,
        sentiment: 'love',
        intensity: 0.9,
        notes: 'Biological mother',
        isGenerated: true,
      });

      // Father
      const fatherRequest = this.createFamilyMemberRequest(request, universe, {
        gender: 'male',
        ageOffset: 22 + Math.floor(Math.random() * 15),
        relationToOriginal: 'parent',
      });
      const father = await this.generateSingleCharacter(fatherRequest, universe, character.cascadeDepth + 1);
      father.generatedFrom = character.characterId;
      familyMembers.push(father);

      relationships.push({
        relationshipId: uuidv4(),
        targetCharacterId: father.characterId,
        targetCharacterName: father.name,
        category: RelationshipCategory.FAMILY,
        specificType: 'father',
        familyRelationType: FamilyRelationType.PARENT,
        sentiment: 'love',
        intensity: 0.85,
        notes: 'Biological father',
        isGenerated: true,
      });

      // Link parents as spouses
      mother.relationships.push({
        relationshipId: uuidv4(),
        targetCharacterId: father.characterId,
        targetCharacterName: father.name,
        category: RelationshipCategory.FAMILY,
        specificType: 'husband',
        familyRelationType: FamilyRelationType.SPOUSE,
        sentiment: 'love',
        intensity: 0.8,
        notes: 'Married',
        isGenerated: true,
      });
    }

    // Generate siblings (50% chance of 1-3 siblings)
    if (Math.random() > 0.5 && maxDepth > 0) {
      const siblingCount = 1 + Math.floor(Math.random() * 3);
      for (let i = 0; i < siblingCount; i++) {
        const siblingRequest = this.createFamilyMemberRequest(request, universe, {
          gender: Math.random() > 0.5 ? 'male' : 'female',
          ageOffset: Math.floor(Math.random() * 10) - 5, // -5 to +5 years
          relationToOriginal: 'sibling',
        });
        const sibling = await this.generateSingleCharacter(siblingRequest, universe, character.cascadeDepth + 1);
        sibling.generatedFrom = character.characterId;
        familyMembers.push(sibling);

        const siblingType = sibling.currentAge > character.currentAge ? 'older sibling' : 'younger sibling';
        relationships.push({
          relationshipId: uuidv4(),
          targetCharacterId: sibling.characterId,
          targetCharacterName: sibling.name,
          category: RelationshipCategory.FAMILY,
          specificType: siblingType,
          familyRelationType: FamilyRelationType.SIBLING,
          sentiment: 'like',
          intensity: 0.7,
          notes: `${siblingType}`,
          isGenerated: true,
        });
      }
    }

    // Extended family for non-nuclear structures
    if (familyStructure === 'extended' || familyStructure === 'clan') {
      // Add grandparents, aunts, uncles, cousins (simplified)
      if (maxDepth > 1 && Math.random() > 0.6) {
        const grandparentRequest = this.createFamilyMemberRequest(request, universe, {
          gender: Math.random() > 0.5 ? 'male' : 'female',
          ageOffset: 45 + Math.floor(Math.random() * 20),
          relationToOriginal: 'grandparent',
        });
        const grandparent = await this.generateSingleCharacter(grandparentRequest, universe, character.cascadeDepth + 2);
        grandparent.generatedFrom = character.characterId;
        familyMembers.push(grandparent);

        relationships.push({
          relationshipId: uuidv4(),
          targetCharacterId: grandparent.characterId,
          targetCharacterName: grandparent.name,
          category: RelationshipCategory.FAMILY,
          specificType: grandparent.gender === 'male' ? 'grandfather' : 'grandmother',
          familyRelationType: FamilyRelationType.GRANDPARENT,
          sentiment: 'love',
          intensity: 0.75,
          notes: 'Grandparent',
          isGenerated: true,
        });
      }
    }

    character.triggeredGenerations.push(...familyMembers.map(m => m.characterId));

    return { characters: familyMembers, relationships };
  }

  private createFamilyMemberRequest(
    originalRequest: CharacterGenerationRequest,
    _universe: UniverseContext,
    options: {
      gender: string;
      ageOffset: number;
      relationToOriginal: string;
    }
  ): CharacterGenerationRequest {
    const currentAge = originalRequest.backstoryParams.currentAge || 25;

    return {
      requestId: uuidv4(),
      createdAt: new Date(),
      originType: CharacterOriginType.GENERATED,
      universeId: originalRequest.universeId,
      generationDepth: GenerationDepth.MINIMAL, // Don't cascade from family members
      maxCascadeDepth: 0,
      constraints: {
        ...originalRequest.constraints,
        gender: options.gender,
        ageRange: {
          min: Math.max(0, currentAge + options.ageOffset - 5),
          max: currentAge + options.ageOffset + 5,
        },
      },
      backstoryParams: {
        includeChildhood: true,
        includeTrauma: Math.random() > 0.7,
        includeRomance: options.relationToOriginal === 'parent',
        includeAchievements: Math.random() > 0.5,
        minLifeEvents: 3,
        maxLifeEvents: 8,
        currentAge: currentAge + options.ageOffset,
      },
      generateOptions: {
        generateFamily: false, // Prevent infinite recursion
        generateMentor: false,
        generateRivals: false,
        generateFriends: false,
        generateLocations: true,
        generatePowers: true,
        generateFactionMembership: true,
        expandUniverseContext: false,
      },
      narrativeRole: 'supporting',
      storySignificance: 'minor',
    };
  }

  // ============================================================================
  // Mentor, Rival, Friend Generation
  // ============================================================================

  private async generateMentor(
    character: GeneratedCharacter,
    request: CharacterGenerationRequest,
    universe: UniverseContext
  ): Promise<GeneratedCharacter | null> {
    // 80% chance to have a mentor
    if (Math.random() > 0.8) return null;

    const mentorRequest: CharacterGenerationRequest = {
      requestId: uuidv4(),
      createdAt: new Date(),
      originType: CharacterOriginType.GENERATED,
      universeId: request.universeId,
      generationDepth: GenerationDepth.MINIMAL,
      maxCascadeDepth: 0,
      constraints: {
        ageRange: { min: character.currentAge + 15, max: character.currentAge + 50 },
        powerLevel: 'high',
      },
      backstoryParams: {
        includeChildhood: true,
        includeTrauma: true,
        includeRomance: false,
        includeAchievements: true,
        minLifeEvents: 5,
        maxLifeEvents: 15,
        currentAge: character.currentAge + 20 + Math.floor(Math.random() * 30),
      },
      generateOptions: {
        generateFamily: false,
        generateMentor: false,
        generateRivals: false,
        generateFriends: false,
        generateLocations: true,
        generatePowers: true,
        generateFactionMembership: true,
        expandUniverseContext: false,
      },
      narrativeRole: 'supporting',
      storySignificance: 'moderate',
    };

    const mentor = await this.generateSingleCharacter(mentorRequest, universe, character.cascadeDepth + 1);
    mentor.generatedFrom = character.characterId;
    character.triggeredGenerations.push(mentor.characterId);

    return mentor;
  }

  private async generateRivals(
    character: GeneratedCharacter,
    request: CharacterGenerationRequest,
    universe: UniverseContext
  ): Promise<GeneratedCharacter[]> {
    const rivals: GeneratedCharacter[] = [];
    const rivalCount = Math.floor(Math.random() * 3); // 0-2 rivals

    for (let i = 0; i < rivalCount; i++) {
      const rivalRequest: CharacterGenerationRequest = {
        requestId: uuidv4(),
        createdAt: new Date(),
        originType: CharacterOriginType.GENERATED,
        universeId: request.universeId,
        generationDepth: GenerationDepth.MINIMAL,
        maxCascadeDepth: 0,
        constraints: {
          ageRange: { min: character.currentAge - 5, max: character.currentAge + 5 },
        },
        backstoryParams: {
          includeChildhood: true,
          includeTrauma: Math.random() > 0.5,
          includeRomance: false,
          includeAchievements: true,
          minLifeEvents: 4,
          maxLifeEvents: 10,
          currentAge: character.currentAge + Math.floor(Math.random() * 6) - 3,
        },
        generateOptions: {
          generateFamily: false,
          generateMentor: false,
          generateRivals: false,
          generateFriends: false,
          generateLocations: true,
          generatePowers: true,
          generateFactionMembership: true,
          expandUniverseContext: false,
        },
        narrativeRole: 'supporting',
        storySignificance: 'moderate',
      };

      const rival = await this.generateSingleCharacter(rivalRequest, universe, character.cascadeDepth + 1);
      rival.generatedFrom = character.characterId;
      character.triggeredGenerations.push(rival.characterId);
      rivals.push(rival);
    }

    return rivals;
  }

  private async generateFriends(
    character: GeneratedCharacter,
    request: CharacterGenerationRequest,
    universe: UniverseContext
  ): Promise<GeneratedCharacter[]> {
    const friends: GeneratedCharacter[] = [];
    const friendCount = 1 + Math.floor(Math.random() * 3); // 1-3 friends

    for (let i = 0; i < friendCount; i++) {
      const friendRequest: CharacterGenerationRequest = {
        requestId: uuidv4(),
        createdAt: new Date(),
        originType: CharacterOriginType.GENERATED,
        universeId: request.universeId,
        generationDepth: GenerationDepth.MINIMAL,
        maxCascadeDepth: 0,
        constraints: {
          ageRange: { min: character.currentAge - 10, max: character.currentAge + 10 },
        },
        backstoryParams: {
          includeChildhood: true,
          includeTrauma: Math.random() > 0.7,
          includeRomance: Math.random() > 0.8,
          includeAchievements: Math.random() > 0.5,
          minLifeEvents: 3,
          maxLifeEvents: 8,
          currentAge: character.currentAge + Math.floor(Math.random() * 10) - 5,
        },
        generateOptions: {
          generateFamily: false,
          generateMentor: false,
          generateRivals: false,
          generateFriends: false,
          generateLocations: true,
          generatePowers: true,
          generateFactionMembership: true,
          expandUniverseContext: false,
        },
        narrativeRole: 'supporting',
        storySignificance: 'minor',
      };

      const friend = await this.generateSingleCharacter(friendRequest, universe, character.cascadeDepth + 1);
      friend.generatedFrom = character.characterId;
      character.triggeredGenerations.push(friend.characterId);
      friends.push(friend);
    }

    return friends;
  }

  // ============================================================================
  // Helper Methods for Generation
  // ============================================================================

  private selectSpecies(request: CharacterGenerationRequest, universe: UniverseContext): SpeciesTemplate {
    if (request.constraints.species) {
      const found = universe.availableSpecies.find(s => s.speciesName === request.constraints.species);
      if (found) return found;
    }
    // Default to first available species (usually human)
    return universe.availableSpecies[0] || {
      speciesId: 'default',
      speciesName: 'Human',
      description: 'Standard human',
      lifespan: { min: 60, typical: 75, max: 100 },
      maturityAge: 18,
      physicalTraits: ['varies'],
    };
  }

  private selectCulture(
    request: CharacterGenerationRequest,
    universe: UniverseContext,
    _species: SpeciesTemplate
  ): CultureTemplate {
    if (request.constraints.culture) {
      const found = universe.defaultCultures.find(c => c.cultureName === request.constraints.culture);
      if (found) return found;
    }
    return universe.defaultCultures[0] || {
      cultureId: 'default',
      cultureName: 'Default',
      description: 'Standard culture',
      values: ['survival', 'family'],
      traditions: [],
      typicalOccupations: ['farmer', 'merchant', 'soldier'],
      familyStructure: 'nuclear',
    };
  }

  private generateName(culture: CultureTemplate, universe: UniverseContext): string {
    const convention = universe.namingConventions.find(n => n.cultureName === culture.cultureName);
    if (convention && convention.examples.length > 0) {
      // For now, pick a random example. In production, would use proper name generation
      return convention.examples[Math.floor(Math.random() * convention.examples.length)];
    }
    // Fallback names
    const fallbackNames = ['Alex', 'Morgan', 'Jordan', 'Casey', 'Riley', 'Quinn', 'Avery', 'Sage'];
    return fallbackNames[Math.floor(Math.random() * fallbackNames.length)];
  }

  private calculateAge(request: CharacterGenerationRequest, species: SpeciesTemplate): number {
    if (request.backstoryParams.currentAge) {
      return request.backstoryParams.currentAge;
    }
    if (request.constraints.ageRange) {
      const { min, max } = request.constraints.ageRange;
      return min + Math.floor(Math.random() * (max - min));
    }
    // Default to young adult
    return species.maturityAge + Math.floor(Math.random() * 20);
  }

  private calculateBirthYear(age: number, universe: UniverseContext): number {
    const currentYear = typeof universe.yearInUniverse === 'number' ? universe.yearInUniverse : 1000;
    return currentYear - age;
  }

  private generateAppearance(
    _request: CharacterGenerationRequest,
    species: SpeciesTemplate,
    _culture: CultureTemplate
  ): GeneratedCharacter['appearance'] {
    const heights = ['short', 'below average', 'average', 'above average', 'tall', 'very tall'];
    const builds = ['slight', 'slim', 'average', 'athletic', 'muscular', 'heavy'];
    const hairColors = ['black', 'brown', 'blonde', 'red', 'gray', 'white', 'unusual'];
    const eyeColors = ['brown', 'blue', 'green', 'gray', 'hazel', 'unusual'];
    const skinTones = ['pale', 'fair', 'light', 'medium', 'olive', 'tan', 'brown', 'dark'];

    return {
      height: heights[Math.floor(Math.random() * heights.length)],
      build: builds[Math.floor(Math.random() * builds.length)],
      hairColor: hairColors[Math.floor(Math.random() * hairColors.length)],
      eyeColor: eyeColors[Math.floor(Math.random() * eyeColors.length)],
      skinTone: skinTones[Math.floor(Math.random() * skinTones.length)],
      distinguishingFeatures: species.physicalTraits.slice(0, 2),
      style: 'practical',
    };
  }

  private generatePersonality(
    request: CharacterGenerationRequest,
    culture: CultureTemplate
  ): GeneratedCharacter['personality'] {
    const traits = ['brave', 'cautious', 'curious', 'loyal', 'independent', 'compassionate', 'ambitious', 'reserved'];
    const strengths = ['determination', 'intelligence', 'charisma', 'physical prowess', 'adaptability'];
    const weaknesses = ['pride', 'stubbornness', 'naivety', 'trust issues', 'impulsiveness'];
    const fears = ['failure', 'loss', 'rejection', 'powerlessness', 'the unknown'];
    const desires = ['power', 'knowledge', 'love', 'freedom', 'purpose', 'justice'];

    const alignment = request.constraints.alignment || 'complex';

    return {
      coreTraits: this.shuffleAndPick(traits, 3),
      strengths: this.shuffleAndPick(strengths, 2),
      weaknesses: this.shuffleAndPick(weaknesses, 2),
      fears: this.shuffleAndPick(fears, 2),
      desires: this.shuffleAndPick(desires, 2),
      values: culture.values.slice(0, 3),
      quirks: ['Has a habit', 'Often says a phrase'],
      alignment,
    };
  }

  private shuffleAndPick<T>(array: T[], count: number): T[] {
    const shuffled = [...array].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, count);
  }

  private async generateBackstory(
    request: CharacterGenerationRequest,
    name: string,
    species: SpeciesTemplate,
    culture: CultureTemplate,
    age: number,
    birthYear: number,
    universe: UniverseContext
  ): Promise<{ background: GeneratedCharacter['background']; lifeEvents: GeneratedLifeEvent[] }> {
    const lifeEvents: GeneratedLifeEvent[] = [];

    // Birthplace
    const birthplace = universe.majorLocations[0]?.locationName || 'Unknown Location';

    // Generate life events based on age
    const maxEvents = Math.min(
      request.backstoryParams.maxLifeEvents,
      Math.max(request.backstoryParams.minLifeEvents, Math.floor(age / 5))
    );
    void maxEvents; // Reserved for future dynamic event limiting

    // Always include birth
    lifeEvents.push({
      eventId: uuidv4(),
      eventType: LifeEventType.BIRTH,
      year: birthYear,
      age: 0,
      title: `Birth of ${name}`,
      description: `${name} was born in ${birthplace}`,
      emotionalImpact: 0.5,
      involvedCharacterIds: [],
      consequences: ['Life begins'],
      isPublicKnowledge: true,
    });

    // Add childhood event
    if (request.backstoryParams.includeChildhood && age > 5) {
      lifeEvents.push({
        eventId: uuidv4(),
        eventType: LifeEventType.DISCOVERY,
        year: birthYear + 5 + Math.floor(Math.random() * 5),
        age: 5 + Math.floor(Math.random() * 5),
        title: 'Childhood Discovery',
        description: `${name} discovered their aptitude for ${culture.typicalOccupations[0] || 'learning'}`,
        emotionalImpact: 0.3,
        involvedCharacterIds: [],
        consequences: ['Shaped future path'],
        isPublicKnowledge: false,
      });
    }

    // Add trauma if requested
    if (request.backstoryParams.includeTrauma && age > 10) {
      const traumaAge = 10 + Math.floor(Math.random() * Math.min(age - 10, 15));
      lifeEvents.push({
        eventId: uuidv4(),
        eventType: LifeEventType.TRAUMA,
        year: birthYear + traumaAge,
        age: traumaAge,
        title: 'Traumatic Event',
        description: `${name} experienced a significant traumatic event`,
        emotionalImpact: -0.8,
        involvedCharacterIds: [],
        consequences: ['Lasting psychological impact', 'Changed worldview'],
        isPublicKnowledge: false,
      });
    }

    // Add training/education
    if (age > species.maturityAge - 5) {
      lifeEvents.push({
        eventId: uuidv4(),
        eventType: LifeEventType.TRAINING_START,
        year: birthYear + species.maturityAge - 5,
        age: species.maturityAge - 5,
        title: 'Began Training',
        description: `${name} began formal training in ${culture.typicalOccupations[0] || 'their craft'}`,
        emotionalImpact: 0.4,
        involvedCharacterIds: [],
        consequences: ['Skill development begins'],
        isPublicKnowledge: true,
      });
    }

    // Add achievement if requested
    if (request.backstoryParams.includeAchievements && age > species.maturityAge) {
      const achievementAge = species.maturityAge + Math.floor(Math.random() * (age - species.maturityAge));
      lifeEvents.push({
        eventId: uuidv4(),
        eventType: LifeEventType.ACHIEVEMENT,
        year: birthYear + achievementAge,
        age: achievementAge,
        title: 'Notable Achievement',
        description: `${name} achieved recognition for their abilities`,
        emotionalImpact: 0.6,
        involvedCharacterIds: [],
        consequences: ['Gained reputation', 'New opportunities'],
        isPublicKnowledge: true,
      });
    }

    // Sort by age
    lifeEvents.sort((a, b) => a.age - b.age);

    // Synthesize background narrative
    const background: GeneratedCharacter['background'] = {
      birthplace,
      childhoodSummary: `Grew up in ${birthplace}, ${culture.cultureName} culture.`,
      education: `Trained in ${culture.typicalOccupations[0] || 'various skills'}`,
      occupation: culture.typicalOccupations[Math.floor(Math.random() * culture.typicalOccupations.length)] || 'Adventurer',
      socialClass: request.constraints.socialClass || 'middle',
      wealth: 'modest',
      fullHistory: this.synthesizeHistory(name, lifeEvents, culture),
    };

    return { background, lifeEvents };
  }

  private synthesizeHistory(name: string, events: GeneratedLifeEvent[], culture: CultureTemplate): string {
    const paragraphs: string[] = [];

    paragraphs.push(`${name} was born into ${culture.cultureName} culture, shaped by values of ${culture.values.slice(0, 2).join(' and ')}.`);

    for (const event of events.slice(1)) { // Skip birth
      paragraphs.push(`At age ${event.age}, ${event.description.toLowerCase()}.`);
    }

    return paragraphs.join(' ');
  }

  private generateLocations(
    _request: CharacterGenerationRequest,
    background: GeneratedCharacter['background'],
    lifeEvents: GeneratedLifeEvent[],
    universe: UniverseContext
  ): GeneratedLocation[] {
    const locations: GeneratedLocation[] = [];

    // Birthplace
    locations.push({
      locationId: uuidv4(),
      locationName: background.birthplace,
      importance: LocationImportance.BIRTHPLACE,
      description: `Birthplace of the character`,
      significantEvents: ['Birth'],
      isGenerated: !universe.majorLocations.some(l => l.locationName === background.birthplace),
    });

    // Add location for significant events
    for (const event of lifeEvents) {
      if (event.eventType === LifeEventType.TRAINING_START) {
        locations.push({
          locationId: uuidv4(),
          locationName: `Training Grounds`,
          importance: LocationImportance.TRAINING_GROUND,
          description: 'Where training took place',
          significantEvents: [event.title],
          isGenerated: true,
        });
      }
    }

    return locations;
  }

  private generatePowers(
    request: CharacterGenerationRequest,
    species: SpeciesTemplate,
    _culture: CultureTemplate,
    universe: UniverseContext
  ): GeneratedPower[] {
    if (!request.generateOptions.generatePowers) return [];

    const powers: GeneratedPower[] = [];

    // Add innate species abilities
    if (species.innateAbilities) {
      for (const ability of species.innateAbilities) {
        powers.push({
          powerId: uuidv4(),
          powerName: ability,
          systemId: 'innate',
          systemName: 'Innate Abilities',
          proficiency: 80,
          notes: 'Natural species ability',
        });
      }
    }

    // Add powers from universe power systems
    if (universe.powerSystems.length > 0 && request.constraints.powerLevel !== 'none') {
      powers.push({
        powerId: uuidv4(),
        powerName: 'Basic Training',
        systemId: universe.powerSystems[0],
        systemName: universe.powerSystems[0],
        proficiency: 30,
        notes: 'Basic power system training',
      });
    }

    return powers;
  }

  private generateFactionMemberships(
    request: CharacterGenerationRequest,
    _culture: CultureTemplate,
    universe: UniverseContext
  ): GeneratedFactionMembership[] {
    if (!request.generateOptions.generateFactionMembership) return [];

    const memberships: GeneratedFactionMembership[] = [];

    // If constrained to a faction, add it
    if (request.constraints.mustBelongToFaction) {
      const faction = universe.majorFactions.find(f => f.factionId === request.constraints.mustBelongToFaction);
      if (faction) {
        memberships.push({
          factionId: faction.factionId,
          factionName: faction.factionName,
          role: faction.typicalRoles[0] || 'member',
          status: 'active',
          loyaltyLevel: 0.7,
          notes: 'Current member',
        });
      }
    } else if (universe.majorFactions.length > 0 && Math.random() > 0.3) {
      // 70% chance to belong to a faction
      const faction = universe.majorFactions[Math.floor(Math.random() * universe.majorFactions.length)];
      memberships.push({
        factionId: faction.factionId,
        factionName: faction.factionName,
        role: faction.typicalRoles[Math.floor(Math.random() * faction.typicalRoles.length)] || 'member',
        status: 'active',
        loyaltyLevel: 0.5 + Math.random() * 0.4,
        notes: 'Member',
      });
    }

    return memberships;
  }

  private generateVoiceProfile(
    culture: CultureTemplate,
    personality: GeneratedCharacter['personality']
  ): GeneratedCharacter['voiceProfile'] {
    const vocabularyLevels: GeneratedCharacter['voiceProfile']['vocabularyLevel'][] =
      ['simple', 'moderate', 'sophisticated'];

    return {
      vocabularyLevel: vocabularyLevels[Math.floor(Math.random() * vocabularyLevels.length)],
      speechPatterns: [`Values ${culture.values[0] || 'honor'} in speech`],
      favoredExpressions: ['A common saying'],
      internalVoiceTone: personality.coreTraits[0] || 'thoughtful',
    };
  }

  private randomGender(): string {
    return Math.random() > 0.5 ? 'male' : 'female';
  }

  private identifyArcPotential(
    personality: GeneratedCharacter['personality'],
    _background: GeneratedCharacter['background'],
    lifeEvents: GeneratedLifeEvent[]
  ): string[] {
    const arcs: string[] = [];

    if (personality.fears.length > 0) {
      arcs.push(`Overcoming fear of ${personality.fears[0]}`);
    }
    if (personality.desires.length > 0) {
      arcs.push(`Quest for ${personality.desires[0]}`);
    }
    if (lifeEvents.some(e => e.eventType === LifeEventType.TRAUMA)) {
      arcs.push('Healing from past trauma');
    }

    return arcs;
  }

  private identifyPlotHooks(
    background: GeneratedCharacter['background'],
    lifeEvents: GeneratedLifeEvent[],
    factions: GeneratedFactionMembership[]
  ): string[] {
    const hooks: string[] = [];

    hooks.push(`Connection to ${background.birthplace}`);

    if (factions.length > 0) {
      hooks.push(`${factions[0].factionName} involvement`);
    }

    for (const event of lifeEvents) {
      if (event.eventType === LifeEventType.TRAUMA) {
        hooks.push('Unresolved past trauma');
      }
      if (event.eventType === LifeEventType.DISCOVERY) {
        hooks.push('Hidden potential to explore');
      }
    }

    return hooks;
  }

  private buildFamilyTree(
    rootCharacter: GeneratedCharacter,
    familyMembers: GeneratedCharacter[]
  ): FamilyTree {
    const tree: FamilyTree = {
      treeId: uuidv4(),
      rootCharacterId: rootCharacter.characterId,
      members: new Map(),
      generations: new Map(),
      familyName: rootCharacter.name.split(' ').pop() || 'Unknown',
      familyOrigin: rootCharacter.background.birthplace,
      familyTraits: rootCharacter.personality.coreTraits.slice(0, 2),
      familySecrets: [],
      familyWealth: rootCharacter.background.wealth,
      familyReputation: 'unknown',
    };

    // Add root character
    tree.members.set(rootCharacter.characterId, {
      characterId: rootCharacter.characterId,
      characterName: rootCharacter.name,
      generation: 0,
      isAlive: true,
      relationships: { parents: [], children: [], siblings: [], spouses: [] },
    });
    tree.generations.set(0, [rootCharacter.characterId]);

    // Add family members
    for (const member of familyMembers) {
      const relationship = rootCharacter.relationships.find(r => r.targetCharacterId === member.characterId);
      let generation = 0;

      if (relationship?.familyRelationType === FamilyRelationType.PARENT) {
        generation = -1;
      } else if (relationship?.familyRelationType === FamilyRelationType.GRANDPARENT) {
        generation = -2;
      } else if (relationship?.familyRelationType === FamilyRelationType.SIBLING) {
        generation = 0;
      } else if (relationship?.familyRelationType === FamilyRelationType.CHILD) {
        generation = 1;
      }

      tree.members.set(member.characterId, {
        characterId: member.characterId,
        characterName: member.name,
        generation,
        isAlive: !member.deathDate,
        relationships: { parents: [], children: [], siblings: [], spouses: [] },
      });

      if (!tree.generations.has(generation)) {
        tree.generations.set(generation, []);
      }
      tree.generations.get(generation)!.push(member.characterId);
    }

    return tree;
  }

  // ============================================================================
  // Standard API Methods
  // ============================================================================

  getStats(): {
    totalGenerations: number;
    totalCascades: number;
    universeCount: number;
    characterCount: number;
    familyTreeCount: number;
    locationCount: number;
  } {
    return {
      totalGenerations: this.totalGenerations,
      totalCascades: this.totalCascades,
      universeCount: this.universes.size,
      characterCount: this.generatedCharacters.size,
      familyTreeCount: this.familyTrees.size,
      locationCount: this.generatedLocations.size,
    };
  }

  clear(): void {
    this.universes.clear();
    this.generatedCharacters.clear();
    this.familyTrees.clear();
    this.generatedLocations.clear();
    this.charactersByUniverse.clear();
    this.charactersByFaction.clear();
    this.charactersByLocation.clear();
    this.charactersByFamily.clear();
    this.generationQueue = [];
    this.processingResults = [];
    this.totalGenerations = 0;
    this.totalCascades = 0;
  }

  exportToJSON(): string {
    return JSON.stringify({
      universes: Array.from(this.universes.entries()),
      generatedCharacters: Array.from(this.generatedCharacters.entries()),
      familyTrees: Array.from(this.familyTrees.entries()).map(([id, tree]) => [
        id,
        { ...tree, members: Array.from(tree.members.entries()), generations: Array.from(tree.generations.entries()) }
      ]),
      generatedLocations: Array.from(this.generatedLocations.entries()),
      backstoryTemplates: Array.from(this.backstoryTemplates.entries()),
      stats: {
        totalGenerations: this.totalGenerations,
        totalCascades: this.totalCascades,
      },
    }, null, 2);
  }

  importFromJSON(json: string): void {
    const data = JSON.parse(json);

    this.clear();

    this.universes = new Map(data.universes);
    this.generatedCharacters = new Map(data.generatedCharacters);
    this.generatedLocations = new Map(data.generatedLocations);
    this.backstoryTemplates = new Map(data.backstoryTemplates);

    // Restore family trees with Map structures
    for (const [id, treeData] of data.familyTrees) {
      const tree: FamilyTree = {
        ...treeData,
        members: new Map(treeData.members),
        generations: new Map(treeData.generations),
      };
      this.familyTrees.set(id, tree);
    }

    this.totalGenerations = data.stats.totalGenerations;
    this.totalCascades = data.stats.totalCascades;

    // Rebuild indexes
    for (const [charId, char] of this.generatedCharacters) {
      // By universe
      const universeId = char.requestId; // Would need to track universe separately
      if (!this.charactersByUniverse.has(universeId)) {
        this.charactersByUniverse.set(universeId, []);
      }
      this.charactersByUniverse.get(universeId)!.push(charId);

      // By faction
      for (const faction of char.factions) {
        if (!this.charactersByFaction.has(faction.factionId)) {
          this.charactersByFaction.set(faction.factionId, []);
        }
        this.charactersByFaction.get(faction.factionId)!.push(charId);
      }
    }
  }

  // ============================================================================
  // Query Methods
  // ============================================================================

  getCharacter(characterId: string): GeneratedCharacter | undefined {
    return this.generatedCharacters.get(characterId);
  }

  getCharactersByUniverse(universeId: string): GeneratedCharacter[] {
    const ids = this.charactersByUniverse.get(universeId) || [];
    return ids
      .map(id => this.generatedCharacters.get(id))
      .filter((c): c is GeneratedCharacter => c !== undefined);
  }

  getFamilyTree(characterId: string): FamilyTree | undefined {
    for (const tree of this.familyTrees.values()) {
      if (tree.members.has(characterId)) {
        return tree;
      }
    }
    return undefined;
  }

  getCharacterRelationships(characterId: string): GeneratedRelationship[] {
    const character = this.generatedCharacters.get(characterId);
    return character?.relationships || [];
  }
}

// ============================================================================
// Export
// ============================================================================

export default AutoCharacterPipeline;
